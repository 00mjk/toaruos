<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>とあるOS</title><link href="http://toaruos.org/" rel="alternate"></link><link href="http://toaruos.org/feeds/all.atom.xml" rel="self"></link><id>http://toaruos.org/</id><updated>2014-05-12T20:20:00Z</updated><entry><title>Visibly Panicked</title><link href="http://toaruos.org/visibly-panicked.html" rel="alternate"></link><updated>2014-05-12T20:20:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-12:visibly-panicked.html</id><summary type="html">&lt;p&gt;Panic screens are an important part of any OS - they allow you to see not only that you've made a mistake, but often why and how. The panic screen in Windows is particularly infamous, and helpful to some subset of engineers, though not very shiny. OS X has a rather neat, but ultimately not very useful panic screen involving an embedded image in the kernel.&lt;/p&gt;
&lt;p&gt;とあるOS has mostly had debug output like kernel panics written to a serial log. Since I'm usually working in the GUI and often have the logs completely disabled, it made sense to add a new panic format. To that end, I was inspired by a popular video game series, and made these new panic screens:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Q8cce5d.png"&gt;&lt;img alt="Assertion failed - login" src="http://i.imgur.com/Q8cce5d.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/QyDAOxO.png"&gt;&lt;img alt="Assertion failed - desktop" src="http://i.imgur.com/QyDAOxO.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Mjj6886.png"&gt;&lt;img alt="Out of memory" src="http://i.imgur.com/Mjj6886.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The panic handler first outputs to the debug log (if set) and then calls out to the video driver to have it display a visual indicator of failure. The video driver can take an array of messages to display, which are usually &lt;code&gt;sprintf&lt;/code&gt;'d into the kernel stack by the calling fault handler. With this particular setup, the video driver desaturates the dispaly to grayscal, adds a (crude) vignette effect, and then displas the fault message in the center of the screen using an embedded bitmap font.&lt;/p&gt;</summary><category term="kernel"></category></entry><entry><title>Yutani: The new compositor</title><link href="http://toaruos.org/yutani-the-new-compositor.html" rel="alternate"></link><updated>2014-05-10T16:45:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-10:yutani-the-new-compositor.html</id><summary type="html">&lt;p&gt;In developing とあるOS, I've had a consistent focus on UI. Since early 2012, the OS has had a compositing window server, which was hacked together in roughly a week for a hackathon and presented at UIUC's Engineering Open House. Over the past two years, a number of improvements have been made to the compositor, including a rewrite of the graphics layer to use Cairo and the addition of animations. All the while, the compositor suffered from some major preformance issues, partly due to the overall design of the protocol, but mostly due to inabilities of the underlying kernel. Replacing the compositor with a new one, built from scratch with a well-designed API and a focus on performance had been an idea I had floating around in the back of my mind for quite a while, but it was not until April that I finally moved forward in implementing it.&lt;/p&gt;
&lt;p&gt;For those unfamiliar, とあるOS looked something like this in March:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/CsFIScB.png"&gt;&lt;img alt="Screenshot circa March 2014" src="http://i.imgur.com/CsFIScB.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Make note of the framerate the gears application is running at. I believe the last screenshot I have of the old compositor is most likely this one from April 1st:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/JytMEaU.png"&gt;&lt;img alt="Screenshot circa April 2014" src="http://i.imgur.com/JytMEaU.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In building a new compositor, I wanted to focus on solving the more glaring issues in the old one. The first step to this was adding &lt;strong&gt;damage rects&lt;/strong&gt;. Damage rects (short for rectangles) allow the compositor to track when and where clients have made changes to their windows and ensure that only the updated areas are redrawn - the old compositor would assume everything may have changed each time it needed to redraw the screen. In February, I built a prototype in SDL that ran on Linux, demonstrating a simple compositor. The prototype was titled Yutani, a reference to the &lt;em&gt;Alien&lt;/em&gt; franchise and, through that, also a reference to Wayland (the megacorp in Alien is called Weyland-Yutani).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/z82vPQj.png"&gt;&lt;img alt="Yutani prototype, February 2014" src="http://i.imgur.com/z82vPQj.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The prototype couldn't do much - it didn't have any IPC, and the only thing that moved was the mouse cursor, but it did allow me to experiment with using Cairo's clipping functionality to implement damage rects. The prototype sat idle throughout March while I diverted my attention to implementing a module system in the kernel, and then worked on a release candidate for the year's April Fools Day. It wasn't until mid-April that I picked things up again.&lt;/p&gt;
&lt;p&gt;Not wanting to have to completely redesign my client graphics libraries, Yutani needed to operate on the same basic principles as the existing compositor: Windows were stored as shared memory regions with 32-bit RGBA colors. The clients would use a communication pipe to send requests to the server (ie., create a new window, etc.) and receive events (ie., mouse moved, keyboard key pressed, etc.). There was a critical flaw in the IPC mechanism the old compositor used to communicate events: The server was unable to wait for a message from any client (the kernel does not support &lt;code&gt;select()&lt;/code&gt;, even to this day). The workaround employed in the old compositor was to run a thread that would loop through each of the known clients, check if they had data to read, and then process it if so. In designing Yutani, there was an obvious need to rectify the problem. This resulted in the creation of a new kernel IPC mechanism which was dubbed "pex" (short for &lt;strong&gt;p&lt;/strong&gt;acket &lt;strong&gt;ex&lt;/strong&gt;change). Pex operates similarly to Unix sockets in that a server can create an endpoint which multiple clients can then connect to. When the server goes to read from the endpoint, it receives individual packets that include header information describing where the packet came from. The server then responds by writing a similarly-formatted packet back out to the endpoint. Meanwhile, clients read and write raw packets, without headers. Since the server only has to read from a single file to receive data from all of its clients, an implementation of &lt;code&gt;select()&lt;/code&gt; is not needed.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/cIHO3ey.png"&gt;&lt;img alt="Yutani, alpha, April 2014" src="http://i.imgur.com/cIHO3ey.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The first builds of Yutani just drew boxes, but I eventually ported a larger graphical application: the login manager.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/YVvYefW.png"&gt;&lt;img alt="Login manager under Yutani, April 2014" src="http://i.imgur.com/YVvYefW.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next up on the ports list was the terminal.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Koj8sHr.png"&gt;&lt;img alt="Terminal under Yutani, April 2014" src="http://i.imgur.com/Koj8sHr.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eventually, the wallpaper and panel were also ported, but Yutani still lacked window management - it wasn't even possible to change focus.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/cRRZCre.png"&gt;&lt;img alt="Terminal, panel, wallpaper under Yutani" src="http://i.imgur.com/cRRZCre.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To support window management features quickly, code was ported from the old compositor for handling mouse events. With damage rects, window movement needed to be cleaned up:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/EXVTcc7.png"&gt;&lt;img alt="Missing damage regions cause artifacts" src="http://i.imgur.com/EXVTcc7.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eventually, Yutani supported everything the old compositor supported, including window rotation:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/8Ou9G4z.png"&gt;&lt;img alt="Rotated window" src="http://i.imgur.com/8Ou9G4z.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;With Yutani in a state of relative feature parity, the remaining apps were ported and the old compositor was removed from the git repository. It was now time to add more features. The most popularly requested feature was to add a window list to the panel. This required adding the ability to inform the compositor of the names of windows. An advertise-subscribe model was implemented, allowing the panel to subscribe to changes in windows, while clients would advertise their new titles. The panel would be informed not just of new window titles, but also when focus changed and when windows disappeared.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/4WE8nTU.png"&gt;&lt;img alt="Window titles in panel" src="http://i.imgur.com/4WE8nTU.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Expanding on this initial implementation, window icons were added to the advertisements - communicated as identifiers such as &lt;code&gt;utilities-terminal&lt;/code&gt; which the panel would look for in &lt;code&gt;/usr/share/icons/$SIZE/&lt;/code&gt;. The panel design went through a few different iterations on the drawing board before being implemented.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/B88hMEZ.png"&gt;&lt;img alt="Panel with icons" src="http://i.imgur.com/B88hMEZ.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The newest feature added to Yutani is support for global key bindings. An app, such as the panel, can request to steal or intercept specific key sequences, which allows for global bindings like Ctrl+Alt+T to open a terminal. This was further extended to support having the panel manage Alt+Tab to switch windows.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=Ez8e1CIC1W4"&gt;&lt;img alt="Alt-Tab capture from YouTube video" src="http://i.imgur.com/E40lAjr.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(That last screenshot links to a video of Alt-Tab in action.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There's still a lot of things that can be added to Yutani. For now, I'm going to take a break from UI improvements to work on something a bit more useful: a network stack.&lt;/p&gt;</summary><category term="yutani"></category><category term="gui"></category></entry><entry><title>Hello World (Again)</title><link href="http://toaruos.org/hello-world-again.html" rel="alternate"></link><updated>2014-05-10T00:08:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-10:hello-world-again.html</id><summary type="html">&lt;p&gt;I've decided to start from scratch (once again) on the toaruos.org site. This new blog is built on Pelican. I also intend to actually update it more than once in a blue moon. I've been doing a lot of kernel and UI work on とある recently, and there's a lot to talk about.&lt;/p&gt;</summary><category term="meta"></category><category term="blog"></category></entry><entry><title>Test Post Please Ignore</title><link href="http://toaruos.org/test-post-please-ignore.html" rel="alternate"></link><updated>2014-05-09T23:50:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-09:test-post-please-ignore.html</id><summary type="html">&lt;p&gt;Whee! This is a &lt;em&gt;test&lt;/em&gt; post!&lt;/p&gt;</summary><category term="meta"></category><category term="blog"></category></entry></feed>