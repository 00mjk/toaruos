<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>とあるOS</title><link href="http://toaruos.org/" rel="alternate"></link><link href="http://toaruos.org/feeds/misc.atom.xml" rel="self"></link><id>http://toaruos.org/</id><updated>2015-04-20T19:50:00Z</updated><entry><title>Another Year</title><link href="http://toaruos.org/another-year.html" rel="alternate"></link><updated>2015-04-20T19:50:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2015-04-20:another-year.html</id><summary type="html">&lt;p&gt;It's been nearly a year since I last posted an update, but in that year there's been a solid bit of development activitiy.&lt;/p&gt;
&lt;h2&gt;EXT2 drivers&lt;/h2&gt;
&lt;p&gt;If you've been following ToaruOS for a while, you may know that we had some write support for ext2 a very long time ago, but it was kind of broken and unstable. The good news is, that support is back, and it's notably more stable than it was. The bad news is it's still not done, and there are some known bugs and edge cases to work through.&lt;/p&gt;
&lt;h2&gt;More Network Work&lt;/h2&gt;
&lt;p&gt;The kernel networking support has been vastly improved, though it's still not ready for prime time and still not available from userspace. I'm actually working on this right now, toying with some ideas for exposing the network stack through the VFS. Hopefully, we should have some nice demos like a telnet client and an IRC client in the coming months.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/duIsLh7.png"&gt;&lt;img alt="Networking, Star Wars" src="http://i.imgur.com/duIsLh7.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Login Screen Redesign&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/x0mJouI.png"&gt;&lt;img alt="New login screen" src="http://i.imgur.com/x0mJouI.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There have actually been two redesigns of the login screen since the last blog post - one was to use a blurred wallpaper for the background, the other was a more extensive redesign of the widgets. This was a fun little project to make use of Cairo. We're also loading a bunch of configuration information (including the logo, positions of various things, what wallpaper to use for the login screen) from a config file, so you can change settings on the fly, without needing to rebuild.&lt;/p&gt;
&lt;p&gt;Those config files are also in use for the desktop wallpaper, per-user, so you can change your wallpaper without having to copy files around. We've started shipping all of the in-house wallpapers from older revisions, as well as a few new ones over the past year.&lt;/p&gt;
&lt;h2&gt;Doom and Quake&lt;/h2&gt;
&lt;p&gt;The SDL port has been rejuvinated, targeting Yutani instead of the old compositor, and now we have working Doom and Quake ports. The Doom engine is prboom, with sdlquake for Quake.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/i5O8Vcl.png"&gt;&lt;img alt="Quake" src="http://i.imgur.com/i5O8Vcl.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;New Timing Interface&lt;/h2&gt;
&lt;p&gt;The kernel timing APIs have been updated. &lt;code&gt;gettimeofday()&lt;/code&gt; now uses an internal clock rather than always calling the RTC. This means there is some apparent drift, which we try to account for every so often, but it also means accurate timing information is available when you needed it. Additionally, the kernel tick rate has been increased to 1000Hz, or 1ms per click, so we're also more accurate. This affects the multitasking quanta time, as well as the resolution for the uptime information in &lt;code&gt;/proc/uptime&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The new timing interface has been adopted for use in animations on the desktop, so if you're running under software emulation in Bochs or QEMU, you should notice that animations are no longer abysmally slow (they'll just have low framerates). This was helpful with adding new animations to the wallpaper when loading applications, but is also used in the compositor and login screen.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/F2dRiwY.png"&gt;&lt;img alt="Timing resulted in an increased framerate in Gears" src="http://i.imgur.com/F2dRiwY.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;What's New in Yutani&lt;/h2&gt;
&lt;p&gt;Yutani got a number of updates as well, mostly driven by the SDL and Quake ports. Yutani now supports cursor warping and hiding, and will inform clients when a window is moved. A client application, &lt;code&gt;yutani-test&lt;/code&gt;, has been added for debugging - it works a bit like &lt;code&gt;xev&lt;/code&gt;.&lt;/p&gt;</summary><category term="kernel"></category></entry><entry><title>Marching Towards 1.0.0</title><link href="http://toaruos.org/marching-towards-100.html" rel="alternate"></link><updated>2014-06-08T00:20:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-06-08:marching-towards-100.html</id><summary type="html">&lt;p&gt;I'm heading to Tokyo again in under a week, as I routinely do. Before I leave, I wanted get a blog post out covering my recent work on improving "quality of life" in ToaruOS - cleaning up the little nits here and there that have been annoying me and those brave enough to try things out for themselves.&lt;/p&gt;
&lt;h2&gt;Tiling&lt;/h2&gt;
&lt;p&gt;Yutani's window manager is a stacking window manager, but like with Compiz's grid plugin I wanted to implement some simple tiling for "everyday" situations like throwing up terminals with quarter/half splits. This is accomplished with a move and resize, triggered by a keybinding in the compositor. The tiling looks really nice in combination with my older decoration theme, which I've updated to indicate focus.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/3fZvBvo.png"&gt;&lt;img alt="Tiled windows" src="http://i.imgur.com/3fZvBvo.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Display Server Nesting&lt;/h2&gt;
&lt;p&gt;When I first started working on Yutani, I had in the back of my mind the idea that it should be nestable. Since Yutani operates against a "graphics context" provided by my generic graphics library, and since that same library is used for windowed applications running within Yutani, getting Yutani to run as a client of itself wasn't too far-fetched, but it did require some quick changes here and there.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/nhnH1ew.png"&gt;&lt;img alt="Nested Yutani" src="http://i.imgur.com/nhnH1ew.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Window Shaping&lt;/h2&gt;
&lt;p&gt;Yutani inhereted a system for tracking clicks from its older brother called "selection buffers" (also referred to as "click buffers" or "picking buffers"). Selection buffers provide a way to give constant-time lookup by coordinates in a rendered surface, but eat a lot of memory and can be slow to generate. It took me longer than I care to admit to come to conclusion that selection buffers were &lt;em&gt;not&lt;/em&gt; the right way to go moving forward in Yutani, but I eventually came to my senses and replaced my selection buffers with a slower, but much more useful, click-time lookup. Combining this with some (application-controlled) thresholding on window alpha channels allowed for a quick and easy implementation of window shaping: allowing a window's "shape" in the compositor to reflect its contents.&lt;/p&gt;
&lt;p&gt;This is most noticable in the Gears application: Previously, the gears window was a large, mostly transparent box, and any click in that box was delivered to the gears application. With the selection buffer, rectangles were drawn to represent the application windows, so we could at least track rotation, but we could not track the finer details of the gears.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/RP2mY5Q.png"&gt;&lt;img alt="Boxes" src="http://i.imgur.com/RP2mY5Q.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Using the new method, we can now make clicks on the "not gears" map through to the wallpaper below. This screenshot is actually from a transitionary phase where selection buffers were still in use, but demonstrates the window shaping quite well:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Ef32dh5.png"&gt;&lt;img alt="Gears" src="http://i.imgur.com/Ef32dh5.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The shaping of windows is only calculated under the mouse cursor, but we can view the results of this shaping with a debug tool (might want to click on this one):&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/2ZPyE8k.png"&gt;&lt;img alt="Debugging window shapes" src="http://i.imgur.com/2ZPyE8k.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Unix Pipes&lt;/h2&gt;
&lt;p&gt;Toaru's kernel has supported a sort of IPC that I've been calling "pipes" for a very long time now. These pipes were fundamental in the operation of the old compositor, and are still used these days internally for some drivers that require buffering (keyboard, mouse). That said, these were definitely not &lt;em&gt;Unix&lt;/em&gt; pipes, and trying to get things like Bash working with them was a nightmare. Adding proper Unix pipes allowed me to finally have a working Bash - including assigning output to variables. I've also implemented pipes in my own shell.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/9y43ERE.png"&gt;&lt;img alt="Pipes" src="http://i.imgur.com/9y43ERE.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Shebangs&lt;/h2&gt;
&lt;p&gt;Shebangs are those lines you see at the tops of scripts that look like &lt;code&gt;#!/bin/foo&lt;/code&gt; - they tell the kernel's binary loader to take this file and pass its name as an argument to another executable, and they allow scripts like shell scripts and Python files to be executed directly, rather than having to call the interpreter.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/t3ELorx.png"&gt;&lt;img alt="Shebangs" src="http://i.imgur.com/t3ELorx.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;pstree&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;A tool I really like on Linux is &lt;code&gt;pstree&lt;/code&gt;, which shows a visual representation of how the process tree looks (what processes are children of other processes, etc.). Implementing my own &lt;code&gt;pstree&lt;/code&gt; required adding some functionality to &lt;code&gt;procfs&lt;/code&gt; to support parent PIDs. I've also put some work into making &lt;code&gt;ls&lt;/code&gt; more like the GNU version, supporting multiple arguments, human-readable file sizes, and minimizing column widths.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/StAAwXs.png"&gt;&lt;img alt="pstree and ls" src="http://i.imgur.com/StAAwXs.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;VGA terminal improvements&lt;/h2&gt;
&lt;p&gt;The last thing on our list for today is some improvements to the VGA terminal. I fixed a notable bug in line wrapping and also added color mappings from the 256-color palette, and from arbitrary 24-bit and 32-bit colors. Now the prompt looks nice and colorful again in VGA text mode:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/pzy2AIQ.png"&gt;&lt;img alt="VGA text-mode" src="http://i.imgur.com/pzy2AIQ.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And we can &lt;code&gt;cat /usr/share/color-test&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/XeW990L.png"&gt;&lt;img alt="cat /usr/share/color-test" src="http://i.imgur.com/XeW990L.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pstree&lt;/code&gt; also looks nice with some Unicode-to-VGA mappings for line-drawing characters:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/cezN0wE.png"&gt;&lt;img alt="pstree in VGA text-mode" src="http://i.imgur.com/cezN0wE.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I don't know if I'll be able to get much work done over the next week, and I'm sure my Github activity streak will be broken while I'm in Japan. There's still a lot of work to be done for the network stack, which is a major blocker to a "1.0.0" release.&lt;/p&gt;</summary><category term="kernel"></category></entry><entry><title>Visibly Panicked</title><link href="http://toaruos.org/visibly-panicked.html" rel="alternate"></link><updated>2014-05-12T20:20:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-12:visibly-panicked.html</id><summary type="html">&lt;p&gt;Panic screens are an important part of any OS - they allow you to see not only that you've made a mistake, but often why and how. The panic screen in Windows is particularly infamous, and helpful to some subset of engineers, though not very shiny. OS X has a rather neat, but ultimately not very useful panic screen involving an embedded image in the kernel.&lt;/p&gt;
&lt;p&gt;とあるOS has mostly had debug output like kernel panics written to a serial log. Since I'm usually working in the GUI and often have the logs completely disabled, it made sense to add a new panic format. To that end, I was inspired by a popular video game series, and made these new panic screens:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Q8cce5d.png"&gt;&lt;img alt="Assertion failed - login" src="http://i.imgur.com/Q8cce5d.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/QyDAOxO.png"&gt;&lt;img alt="Assertion failed - desktop" src="http://i.imgur.com/QyDAOxO.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Mjj6886.png"&gt;&lt;img alt="Out of memory" src="http://i.imgur.com/Mjj6886.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The panic handler first outputs to the debug log (if set) and then calls out to the video driver to have it display a visual indicator of failure. The video driver can take an array of messages to display, which are usually &lt;code&gt;sprintf&lt;/code&gt;'d into the kernel stack by the calling fault handler. With this particular setup, the video driver desaturates the dispaly to grayscale, adds a (crude) vignette effect, and then displas the fault message in the center of the screen using an embedded bitmap font.&lt;/p&gt;</summary><category term="kernel"></category></entry><entry><title>Yutani: The new compositor</title><link href="http://toaruos.org/yutani-the-new-compositor.html" rel="alternate"></link><updated>2014-05-10T16:45:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-10:yutani-the-new-compositor.html</id><summary type="html">&lt;p&gt;In developing とあるOS, I've had a consistent focus on UI. Since early 2012, the OS has had a compositing window server, which was hacked together in roughly a week for a hackathon and presented at UIUC's Engineering Open House. Over the past two years, a number of improvements have been made to the compositor, including a rewrite of the graphics layer to use Cairo and the addition of animations. All the while, the compositor suffered from some major preformance issues, partly due to the overall design of the protocol, but mostly due to inabilities of the underlying kernel. Replacing the compositor with a new one, built from scratch with a well-designed API and a focus on performance had been an idea I had floating around in the back of my mind for quite a while, but it was not until April that I finally moved forward in implementing it.&lt;/p&gt;
&lt;p&gt;For those unfamiliar, とあるOS looked something like this in March:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/CsFIScB.png"&gt;&lt;img alt="Screenshot circa March 2014" src="http://i.imgur.com/CsFIScB.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Make note of the framerate the gears application is running at. I believe the last screenshot I have of the old compositor is most likely this one from April 1st:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/JytMEaU.png"&gt;&lt;img alt="Screenshot circa April 2014" src="http://i.imgur.com/JytMEaU.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In building a new compositor, I wanted to focus on solving the more glaring issues in the old one. The first step to this was adding &lt;strong&gt;damage rects&lt;/strong&gt;. Damage rects (short for rectangles) allow the compositor to track when and where clients have made changes to their windows and ensure that only the updated areas are redrawn - the old compositor would assume everything may have changed each time it needed to redraw the screen. In February, I built a prototype in SDL that ran on Linux, demonstrating a simple compositor. The prototype was titled Yutani, a reference to the &lt;em&gt;Alien&lt;/em&gt; franchise and, through that, also a reference to Wayland (the megacorp in Alien is called Weyland-Yutani).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/z82vPQj.png"&gt;&lt;img alt="Yutani prototype, February 2014" src="http://i.imgur.com/z82vPQj.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The prototype couldn't do much - it didn't have any IPC, and the only thing that moved was the mouse cursor, but it did allow me to experiment with using Cairo's clipping functionality to implement damage rects. The prototype sat idle throughout March while I diverted my attention to implementing a module system in the kernel, and then worked on a release candidate for the year's April Fools Day. It wasn't until mid-April that I picked things up again.&lt;/p&gt;
&lt;p&gt;Not wanting to have to completely redesign my client graphics libraries, Yutani needed to operate on the same basic principles as the existing compositor: Windows were stored as shared memory regions with 32-bit RGBA colors. The clients would use a communication pipe to send requests to the server (ie., create a new window, etc.) and receive events (ie., mouse moved, keyboard key pressed, etc.). There was a critical flaw in the IPC mechanism the old compositor used to communicate events: The server was unable to wait for a message from any client (the kernel does not support &lt;code&gt;select()&lt;/code&gt;, even to this day). The workaround employed in the old compositor was to run a thread that would loop through each of the known clients, check if they had data to read, and then process it if so. In designing Yutani, there was an obvious need to rectify the problem. This resulted in the creation of a new kernel IPC mechanism which was dubbed "pex" (short for &lt;strong&gt;p&lt;/strong&gt;acket &lt;strong&gt;ex&lt;/strong&gt;change). Pex operates similarly to Unix sockets in that a server can create an endpoint which multiple clients can then connect to. When the server goes to read from the endpoint, it receives individual packets that include header information describing where the packet came from. The server then responds by writing a similarly-formatted packet back out to the endpoint. Meanwhile, clients read and write raw packets, without headers. Since the server only has to read from a single file to receive data from all of its clients, an implementation of &lt;code&gt;select()&lt;/code&gt; is not needed.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/cIHO3ey.png"&gt;&lt;img alt="Yutani, alpha, April 2014" src="http://i.imgur.com/cIHO3ey.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The first builds of Yutani just drew boxes, but I eventually ported a larger graphical application: the login manager.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/YVvYefW.png"&gt;&lt;img alt="Login manager under Yutani, April 2014" src="http://i.imgur.com/YVvYefW.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Next up on the ports list was the terminal.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/Koj8sHr.png"&gt;&lt;img alt="Terminal under Yutani, April 2014" src="http://i.imgur.com/Koj8sHr.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eventually, the wallpaper and panel were also ported, but Yutani still lacked window management - it wasn't even possible to change focus.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/cRRZCre.png"&gt;&lt;img alt="Terminal, panel, wallpaper under Yutani" src="http://i.imgur.com/cRRZCre.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To support window management features quickly, code was ported from the old compositor for handling mouse events. With damage rects, window movement needed to be cleaned up:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/EXVTcc7.png"&gt;&lt;img alt="Missing damage regions cause artifacts" src="http://i.imgur.com/EXVTcc7.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eventually, Yutani supported everything the old compositor supported, including window rotation:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/8Ou9G4z.png"&gt;&lt;img alt="Rotated window" src="http://i.imgur.com/8Ou9G4z.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;With Yutani in a state of relative feature parity, the remaining apps were ported and the old compositor was removed from the git repository. It was now time to add more features. The most popularly requested feature was to add a window list to the panel. This required adding the ability to inform the compositor of the names of windows. An advertise-subscribe model was implemented, allowing the panel to subscribe to changes in windows, while clients would advertise their new titles. The panel would be informed not just of new window titles, but also when focus changed and when windows disappeared.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/4WE8nTU.png"&gt;&lt;img alt="Window titles in panel" src="http://i.imgur.com/4WE8nTU.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Expanding on this initial implementation, window icons were added to the advertisements - communicated as identifiers such as &lt;code&gt;utilities-terminal&lt;/code&gt; which the panel would look for in &lt;code&gt;/usr/share/icons/$SIZE/&lt;/code&gt;. The panel design went through a few different iterations on the drawing board before being implemented.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://i.imgur.com/B88hMEZ.png"&gt;&lt;img alt="Panel with icons" src="http://i.imgur.com/B88hMEZ.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The newest feature added to Yutani is support for global key bindings. An app, such as the panel, can request to steal or intercept specific key sequences, which allows for global bindings like Ctrl+Alt+T to open a terminal. This was further extended to support having the panel manage Alt+Tab to switch windows.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=Ez8e1CIC1W4"&gt;&lt;img alt="Alt-Tab capture from YouTube video" src="http://i.imgur.com/E40lAjr.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(That last screenshot links to a video of Alt-Tab in action.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There's still a lot of things that can be added to Yutani. For now, I'm going to take a break from UI improvements to work on something a bit more useful: a network stack.&lt;/p&gt;</summary><category term="yutani"></category><category term="gui"></category></entry><entry><title>Hello World (Again)</title><link href="http://toaruos.org/hello-world-again.html" rel="alternate"></link><updated>2014-05-10T00:08:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-10:hello-world-again.html</id><summary type="html">&lt;p&gt;I've decided to start from scratch (once again) on the toaruos.org site. This new blog is built on Pelican. I also intend to actually update it more than once in a blue moon. I've been doing a lot of kernel and UI work on とある recently, and there's a lot to talk about.&lt;/p&gt;</summary><category term="meta"></category><category term="blog"></category></entry><entry><title>Test Post Please Ignore</title><link href="http://toaruos.org/test-post-please-ignore.html" rel="alternate"></link><updated>2014-05-09T23:50:00Z</updated><author><name>Kevin Lange</name></author><id>tag:toaruos.org,2014-05-09:test-post-please-ignore.html</id><summary type="html">&lt;p&gt;Whee! This is a &lt;em&gt;test&lt;/em&gt; post!&lt;/p&gt;</summary><category term="meta"></category><category term="blog"></category></entry></feed>